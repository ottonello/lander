<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lunar Lander Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #333;
            background: linear-gradient(to bottom, #000428, #004e92);
            outline: none;
            cursor: crosshair;
        }
        
        canvas:focus {
            border-color: #666;
        }
        
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        
        .info {
            margin-top: 10px;
            display: flex;
            gap: 30px;
            font-size: 18px;
        }
        
        .game-over, .difficulty-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        .difficulty-screen {
            display: block;
        }
        
        .difficulty-button {
            display: block;
            width: 200px;
            margin: 10px auto;
            padding: 15px;
            font-size: 16px;
        }
        
        .difficulty-easy { border-color: #4CAF50; }
        .difficulty-medium { border-color: #FF9800; }
        .difficulty-hard { border-color: #F44336; }
        .difficulty-nightmare { border-color: #9C27B0; }
        
        button {
            background: #333;
            color: #fff;
            border: 2px solid #666;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            font-family: inherit;
        }
        
        button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <h1>üöÄ Lunar Lander</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <p><strong>Controls:</strong> Arrow Keys to thrust | Enter to pause | Space to restart</p>
        <p>Land gently on the flat surfaces to win!</p>
        <p><em>Click on the game area if controls stop working</em></p>
        <button onclick="toggleMusic()" id="musicToggle" style="margin-top: 10px;">üéµ Music: ON</button>
    </div>
    
    <div class="info">
        <div>Score: <span id="score">0</span></div>
        <div>Fuel: <span id="fuel">100</span>%</div>
        <div>Altitude: <span id="altitude">0</span>m</div>
        <div>Velocity: <span id="velocity">0.0</span> m/s</div>
    </div>
    
    <div class="difficulty-screen" id="difficultyScreen">
        <h2>üöÄ Select Difficulty</h2>
        <p>Choose your mission difficulty level</p>
        
        <button class="difficulty-button difficulty-easy" onclick="startGame('easy')">
            <strong>EASY</strong><br>
            Low gravity ‚Ä¢ Large landing pads ‚Ä¢ Smooth terrain ‚Ä¢ Efficient fuel
        </button>
        
        <button class="difficulty-button difficulty-medium" onclick="startGame('medium')">
            <strong>MEDIUM</strong><br>
            Normal gravity ‚Ä¢ Medium landing pads ‚Ä¢ Moderate terrain ‚Ä¢ Standard fuel
        </button>
        
        <button class="difficulty-button difficulty-hard" onclick="startGame('hard')">
            <strong>HARD</strong><br>
            High gravity ‚Ä¢ Small landing pads ‚Ä¢ Rough terrain ‚Ä¢ Higher fuel usage
        </button>
        
        <button class="difficulty-button difficulty-nightmare" onclick="startGame('nightmare')">
            <strong>NIGHTMARE</strong><br>
            Extreme gravity ‚Ä¢ Tiny landing pads ‚Ä¢ Chaotic terrain ‚Ä¢ Fuel hungry
        </button>
        
        <div style="margin-top: 20px;">
            <button onclick="showHighscores()">üèÜ View Highscores</button>
        </div>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2 id="gameOverTitle">Game Over</h2>
        <p id="gameOverMessage"></p>
        <div id="scoreBreakdown" style="margin: 20px 0; font-size: 14px; text-align: left;"></div>
        <button onclick="restartGame()">Play Again</button>
        <button onclick="showDifficultyScreen()">Change Difficulty</button>
        <button onclick="showHighscores()">View Highscores</button>
    </div>
    
    <div class="game-over" id="highscoreScreen">
        <h2>üèÜ Highscores</h2>
        <div style="display: flex; gap: 20px; justify-content: center; margin: 20px 0;">
            <button onclick="showHighscoreTab('easy')" id="hsEasy">Easy</button>
            <button onclick="showHighscoreTab('medium')" id="hsMedium">Medium</button>
            <button onclick="showHighscoreTab('hard')" id="hsHard">Hard</button>
            <button onclick="showHighscoreTab('nightmare')" id="hsNightmare">Nightmare</button>
        </div>
        <div id="highscoreList" style="min-height: 200px; text-align: left; font-size: 14px;"></div>
        <button onclick="hideHighscores()">Back</button>
        <button onclick="clearHighscores()" style="background: #800;">Clear All Scores</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let game = {
            lander: {
                x: 400,
                y: 50,
                vx: 0,
                vy: 0,
                angle: 0,
                fuel: 100,
                thrust: false,
                thrustLeft: false,
                thrustRight: false,
                size: 15
            },
            gravity: 0.1,
            thrustPower: 0.2,
            rotationSpeed: 0.05,
            gameOver: false,
            won: false,
            stars: [],
            gameStarted: false,
            difficulty: 'medium',
            paused: false,
            score: 0,
            startTime: 0,
            endTime: 0
        };
        
        // Scoring system
        const scoring = {
            difficultyMultipliers: {
                easy: 1,
                medium: 2,
                hard: 3,
                nightmare: 5
            },
            bonuses: {
                fuelBonus: 10,        // Points per % fuel remaining
                speedBonus: 500,      // Bonus for gentle landing
                precisionBonus: 1000, // Bonus for landing in center of pad
                timeBonus: 2          // Points per second saved (under 60s)
            }
        };
        
        // Sound system
        let audioContext;
        let sounds = {
            thrust: null,
            rotationThrust: null,
            landing: null,
            crash: null,
            button: null,
            music: {
                oscillators: [],
                gainNodes: [],
                playing: false
            }
        };
        
        // Initialize audio context
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Web Audio API not supported');
                return false;
            }
            return true;
        }
        
        // Create ambient space music
        function startBackgroundMusic() {
            if (!audioContext || sounds.music.playing) return;
            
            sounds.music.playing = true;
            
            // Create a more dynamic music system with melodies and pauses
            function playAmbientPhrase() {
                if (!sounds.music.playing) return;
                
                // Random melody notes from a space-like scale
                const notes = [220, 246.94, 293.66, 329.63, 369.99, 415.30, 466.16]; // A minor pentatonic + some
                const melody = [];
                const phraseLength = 4 + Math.floor(Math.random() * 4); // 4-7 notes
                
                for (let i = 0; i < phraseLength; i++) {
                    melody.push(notes[Math.floor(Math.random() * notes.length)]);
                }
                
                // Play the melody
                melody.forEach((freq, index) => {
                    setTimeout(() => {
                        if (!sounds.music.playing) return;
                        
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        
                        osc.type = Math.random() > 0.5 ? 'sine' : 'triangle';
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(1200 + Math.random() * 800, audioContext.currentTime);
                        filter.Q.setValueAtTime(0.5, audioContext.currentTime);
                        
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.03, audioContext.currentTime + 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(audioContext.destination);
                        
                        osc.start();
                        osc.stop(audioContext.currentTime + 2);
                        
                    }, index * 800 + Math.random() * 400); // Staggered timing with variation
                });
                
                // Schedule next phrase with a pause
                const nextPhraseDelay = (phraseLength * 800) + 3000 + Math.random() * 5000; // 3-8 second pause
                setTimeout(playAmbientPhrase, nextPhraseDelay);
            }
            
            // Add subtle bass drone that comes and goes
            function playBassDrone() {
                if (!sounds.music.playing) return;
                
                const bassFreq = [55, 73.42, 82.41][Math.floor(Math.random() * 3)];
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(bassFreq, audioContext.currentTime);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, audioContext.currentTime);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.015, audioContext.currentTime + 2);
                gain.gain.linearRampToValueAtTime(0.015, audioContext.currentTime + 8);
                gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 10);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.start();
                osc.stop(audioContext.currentTime + 10);
                
                sounds.music.oscillators.push(osc);
                sounds.music.gainNodes.push(gain);
                
                // Schedule next bass drone
                setTimeout(playBassDrone, 15000 + Math.random() * 10000); // 15-25 seconds
            }
            
            // Add atmospheric pads occasionally
            function playAtmosphericPad() {
                if (!sounds.music.playing) return;
                
                const chordFreqs = [
                    [220, 261.63, 329.63], // Am
                    [246.94, 293.66, 369.99], // Bm
                    [196, 246.94, 293.66] // G
                ][Math.floor(Math.random() * 3)];
                
                chordFreqs.forEach((freq, index) => {
                    setTimeout(() => {
                        if (!sounds.music.playing) return;
                        
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(600, audioContext.currentTime);
                        filter.Q.setValueAtTime(1, audioContext.currentTime);
                        
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.008, audioContext.currentTime + 3);
                        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 12);
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(audioContext.destination);
                        
                        osc.start();
                        osc.stop(audioContext.currentTime + 12);
                        
                        sounds.music.oscillators.push(osc);
                        sounds.music.gainNodes.push(gain);
                        
                    }, index * 100);
                });
                
                // Schedule next pad
                setTimeout(playAtmosphericPad, 25000 + Math.random() * 15000); // 25-40 seconds
            }
            
            // Start the different musical elements with delays
            setTimeout(playAmbientPhrase, 1000);
            setTimeout(playBassDrone, 5000);
            setTimeout(playAtmosphericPad, 12000);
        }
        
        function stopBackgroundMusic() {
            if (!sounds.music.playing) return;
            
            sounds.music.playing = false;
            
            // Fade out and stop all music oscillators
            sounds.music.gainNodes.forEach(gainNode => {
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
            });
            
            setTimeout(() => {
                sounds.music.oscillators.forEach(osc => {
                    try {
                        osc.stop();
                    } catch (e) {
                        // Oscillator might already be stopped
                    }
                });
                sounds.music.oscillators = [];
                sounds.music.gainNodes = [];
            }, 1100);
        }
        
        // Create sound effects using oscillators
        function createThrustSound() {
            if (!audioContext) return null;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(200, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            return { oscillator, gainNode };
        }
        
        function createRotationThrustSound() {
            if (!audioContext) return null;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            return { oscillator, gainNode };
        }
        
        function playLandingSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.5);
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        function playCrashSound() {
            if (!audioContext) return;
            
            // Create explosion-like sound with noise
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
            }
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            source.buffer = buffer;
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            source.start();
        }
        
        function playButtonSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // Sound management
        function startThrustSound() {
            if (sounds.thrust) return; // Already playing
            sounds.thrust = createThrustSound();
            if (sounds.thrust) {
                sounds.thrust.oscillator.start();
            }
        }
        
        function stopThrustSound() {
            if (sounds.thrust) {
                sounds.thrust.oscillator.stop();
                sounds.thrust = null;
            }
        }
        
        function startRotationThrustSound() {
            if (sounds.rotationThrust) return; // Already playing
            sounds.rotationThrust = createRotationThrustSound();
            if (sounds.rotationThrust) {
                sounds.rotationThrust.oscillator.start();
            }
        }
        
        function stopRotationThrustSound() {
            if (sounds.rotationThrust) {
                sounds.rotationThrust.oscillator.stop();
                sounds.rotationThrust = null;
            }
        }
        
        // Music control
        let musicEnabled = true;
        
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            const button = document.getElementById('musicToggle');
            
            if (musicEnabled) {
                button.textContent = 'üéµ Music: ON';
                if (game.gameStarted && !game.gameOver) {
                    startBackgroundMusic();
                }
            } else {
                button.textContent = 'üîá Music: OFF';
                stopBackgroundMusic();
            }
            
            playButtonSound();
        }
        
        // Highscores (stored in localStorage)
        let highscores = JSON.parse(localStorage.getItem('lunarLanderHighscores')) || {
            easy: [],
            medium: [],
            hard: [],
            nightmare: []
        };
        
        // Difficulty settings
        const difficulties = {
            easy: {
                gravity: 0.015,
                thrustPower: 0.15,
                fuelConsumptionMain: 0.05,
                fuelConsumptionRotation: 0.02,
                landingPadSize: 120,
                terrainRoughness: 10,
                landingPads: [
                    { start: 100, end: 220, height: canvas.height - 80 },
                    { start: 340, end: 460, height: canvas.height - 120 },
                    { start: 580, end: 700, height: canvas.height - 60 }
                ]
            },
            medium: {
                gravity: 0.03,
                thrustPower: 0.12,
                fuelConsumptionMain: 0.08,
                fuelConsumptionRotation: 0.03,
                landingPadSize: 80,
                terrainRoughness: 20,
                landingPads: [
                    { start: 160, end: 240, height: canvas.height - 80 },
                    { start: 420, end: 500, height: canvas.height - 120 },
                    { start: 660, end: 740, height: canvas.height - 60 }
                ]
            },
            hard: {
                gravity: 0.05,
                thrustPower: 0.1,
                fuelConsumptionMain: 0.12,
                fuelConsumptionRotation: 0.05,
                landingPadSize: 60,
                terrainRoughness: 35,
                landingPads: [
                    { start: 180, end: 240, height: canvas.height - 90 },
                    { start: 370, end: 430, height: canvas.height - 140 },
                    { start: 620, end: 680, height: canvas.height - 70 }
                ]
            },
            nightmare: {
                gravity: 0.07,
                thrustPower: 0.08,
                fuelConsumptionMain: 0.15,
                fuelConsumptionRotation: 0.08,
                landingPadSize: 40,
                terrainRoughness: 50,
                landingPads: [
                    { start: 200, end: 240, height: canvas.height - 100 },
                    { start: 380, end: 420, height: canvas.height - 160 },
                    { start: 600, end: 640, height: canvas.height - 80 }
                ]
            }
        };
        
        // Generate random stars for background
        function generateStars() {
            game.stars = [];
            for (let i = 0; i < 100; i++) {
                game.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.7,
                    brightness: Math.random()
                });
            }
        }
        
        // Terrain generation
        const terrain = [];
        function generateTerrain() {
            terrain.length = 0;
            let height = canvas.height - 100;
            
            const diffSettings = difficulties[game.difficulty];
            const landingPads = diffSettings.landingPads;
            const roughness = diffSettings.terrainRoughness;
            
            for (let x = 0; x <= canvas.width; x += 10) {
                let isLandingPad = false;
                let padHeight = height;
                
                // Check if this x position is on a landing pad
                for (let pad of landingPads) {
                    if (x >= pad.start && x <= pad.end) {
                        isLandingPad = true;
                        padHeight = pad.height;
                        break;
                    }
                }
                
                if (isLandingPad) {
                    height = padHeight;
                } else {
                    // Add randomness based on difficulty
                    height += (Math.random() - 0.5) * roughness;
                    height = Math.max(canvas.height - 250, Math.min(canvas.height - 40, height));
                }
                
                terrain.push({ x: x, y: height, isLandingPad: isLandingPad });
            }
        }
        
        // Input handling
        const keys = {
            ArrowUp: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            Enter: false
        };
        
        document.addEventListener('keydown', (e) => {
            if (e.code in keys) {
                keys[e.code] = true;
                e.preventDefault();
            }
            
            if (e.code === 'Space' && game.gameOver) {
                restartGame();
                e.preventDefault();
            }
            
            if (e.code === 'Enter' && game.gameStarted && !game.gameOver) {
                game.paused = !game.paused;
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code in keys) {
                keys[e.code] = false;
                e.preventDefault();
            }
        });
        
        window.addEventListener('blur', () => {
            Object.keys(keys).forEach(key => keys[key] = false);
        });
        
        function handleInput() {
            if (game.gameOver || !game.gameStarted || game.paused) return;
            
            const diffSettings = difficulties[game.difficulty];
            
            game.lander.thrust = false;
            game.lander.thrustLeft = false;
            game.lander.thrustRight = false;
            
            // Handle main thrust
            if (keys.ArrowUp && game.lander.fuel > 0) {
                game.lander.thrust = true;
                game.lander.fuel -= diffSettings.fuelConsumptionMain;
                game.lander.fuel = Math.max(0, game.lander.fuel);
                startThrustSound();
            } else {
                stopThrustSound();
            }
            
            // Handle rotation thrust
            let rotationActive = false;
            if (keys.ArrowLeft && game.lander.fuel > 0) {
                game.lander.thrustLeft = true;
                game.lander.fuel -= diffSettings.fuelConsumptionRotation;
                game.lander.fuel = Math.max(0, game.lander.fuel);
                rotationActive = true;
            }
            
            if (keys.ArrowRight && game.lander.fuel > 0) {
                game.lander.thrustRight = true;
                game.lander.fuel -= diffSettings.fuelConsumptionRotation;
                game.lander.fuel = Math.max(0, game.lander.fuel);
                rotationActive = true;
            }
            
            // Manage rotation thrust sound
            if (rotationActive) {
                startRotationThrustSound();
            } else {
                stopRotationThrustSound();
            }
        }
        
        function updatePhysics() {
            if (game.gameOver || !game.gameStarted || game.paused) return;
            
            const lander = game.lander;
            const diffSettings = difficulties[game.difficulty];
            
            if (lander.thrust) {
                const thrustX = Math.sin(lander.angle) * diffSettings.thrustPower;
                const thrustY = -Math.cos(lander.angle) * diffSettings.thrustPower;
                lander.vx += thrustX;
                lander.vy += thrustY;
            }
            
            if (lander.thrustLeft) {
                lander.angle -= game.rotationSpeed;
            }
            if (lander.thrustRight) {
                lander.angle += game.rotationSpeed;
            }
            
            lander.vy += diffSettings.gravity;
            
            lander.x += lander.vx;
            lander.y += lander.vy;
            
            lander.vx *= 0.999;
            lander.vy *= 0.999;
            
            if (lander.x < 0) {
                lander.x = 0;
                lander.vx = Math.abs(lander.vx) * 0.5;
            }
            if (lander.x > canvas.width) {
                lander.x = canvas.width;
                lander.vx = -Math.abs(lander.vx) * 0.5;
            }
            
            if (lander.y < 0) {
                lander.y = 0;
                lander.vy = Math.abs(lander.vy) * 0.5;
            }
            
            checkCollision();
        }
        
        function calculateScore() {
            if (!game.won) return 0;
            
            const timeTaken = (game.endTime - game.startTime) / 1000; // seconds
            const fuelRemaining = Math.max(0, game.lander.fuel);
            const landingSpeed = Math.sqrt(game.lander.vx * game.lander.vx + game.lander.vy * game.lander.vy);
            const diffMultiplier = scoring.difficultyMultipliers[game.difficulty];
            
            let score = 1000; // Base score for successful landing
            
            // Fuel bonus
            const fuelBonus = Math.round(fuelRemaining * scoring.bonuses.fuelBonus);
            score += fuelBonus;
            
            // Speed bonus (gentle landing)
            if (landingSpeed < 1) {
                score += scoring.bonuses.speedBonus;
            }
            
            // Time bonus (if under 60 seconds)
            let timeBonus = 0;
            if (timeTaken < 60) {
                timeBonus = Math.round((60 - timeTaken) * scoring.bonuses.timeBonus);
                score += timeBonus;
            }
            
            // Precision bonus (landing near center of pad)
            const precisionBonus = scoring.bonuses.precisionBonus;
            score += precisionBonus;
            
            // Apply difficulty multiplier
            score = Math.round(score * diffMultiplier);
            
            return {
                total: score,
                breakdown: {
                    base: Math.round(1000 * diffMultiplier),
                    fuel: Math.round(fuelBonus * diffMultiplier),
                    speed: landingSpeed < 1 ? Math.round(scoring.bonuses.speedBonus * diffMultiplier) : 0,
                    time: Math.round(timeBonus * diffMultiplier),
                    precision: Math.round(precisionBonus * diffMultiplier),
                    multiplier: diffMultiplier
                },
                stats: {
                    time: timeTaken,
                    fuel: fuelRemaining,
                    speed: landingSpeed
                }
            };
        }
        
        function addHighscore(difficulty, score, stats) {
            const entry = {
                score: score,
                date: new Date().toLocaleDateString(),
                time: stats.time.toFixed(1),
                fuel: stats.fuel.toFixed(1),
                speed: stats.speed.toFixed(2)
            };
            
            highscores[difficulty].push(entry);
            highscores[difficulty].sort((a, b) => b.score - a.score);
            highscores[difficulty] = highscores[difficulty].slice(0, 10); // Keep top 10
            
            localStorage.setItem('lunarLanderHighscores', JSON.stringify(highscores));
        }
        
        function showHighscores() {
            document.getElementById('difficultyScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('highscoreScreen').style.display = 'block';
            showHighscoreTab('medium'); // Default to medium
        }
        
        function hideHighscores() {
            document.getElementById('highscoreScreen').style.display = 'none';
            if (game.gameStarted) {
                document.getElementById('gameOver').style.display = 'block';
            } else {
                document.getElementById('difficultyScreen').style.display = 'block';
            }
        }
        
        function showHighscoreTab(difficulty) {
            // Update button styles
            document.querySelectorAll('#highscoreScreen button').forEach(btn => {
                btn.style.background = '#333';
            });
            document.getElementById('hs' + difficulty.charAt(0).toUpperCase() + difficulty.slice(1)).style.background = '#555';
            
            const list = document.getElementById('highscoreList');
            const scores = highscores[difficulty];
            
            if (scores.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #666;">No scores yet for ' + difficulty + ' difficulty</p>';
                return;
            }
            
            let html = '<h3>' + difficulty.toUpperCase() + ' DIFFICULTY</h3>';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 1px solid #666;"><th>Rank</th><th>Score</th><th>Time</th><th>Fuel</th><th>Speed</th><th>Date</th></tr>';
            
            scores.forEach((entry, index) => {
                html += `<tr style="border-bottom: 1px solid #333;">
                    <td>${index + 1}</td>
                    <td style="font-weight: bold;">${entry.score}</td>
                    <td>${entry.time}s</td>
                    <td>${entry.fuel}%</td>
                    <td>${entry.speed} m/s</td>
                    <td>${entry.date}</td>
                </tr>`;
            });
            
            html += '</table>';
            list.innerHTML = html;
        }
        
        function clearHighscores() {
            if (confirm('Are you sure you want to clear all highscores?')) {
                highscores = { easy: [], medium: [], hard: [], nightmare: [] };
                localStorage.removeItem('lunarLanderHighscores');
                showHighscoreTab('medium');
            }
        }
        
        function checkCollision() {
            const lander = game.lander;
            const landerBottom = lander.y + lander.size;
            
            let terrainHeight = canvas.height;
            let isOnLandingPad = false;
            
            for (let i = 0; i < terrain.length - 1; i++) {
                if (lander.x >= terrain[i].x && lander.x <= terrain[i + 1].x) {
                    terrainHeight = terrain[i].y;
                    isOnLandingPad = terrain[i].isLandingPad;
                    break;
                }
            }
            
            if (landerBottom >= terrainHeight) {
                game.endTime = Date.now();
                const speed = Math.sqrt(lander.vx * lander.vx + lander.vy * lander.vy);
                const angle = Math.abs(lander.angle);
                
                // Stop all thrust sounds
                stopThrustSound();
                stopRotationThrustSound();
                
                if (isOnLandingPad && speed < 2 && angle < 0.3) {
                    // Successful landing
                    game.won = true;
                    game.gameOver = true;
                    
                    // Play landing sound
                    playLandingSound();
                    
                    // Calculate score
                    const scoreData = calculateScore();
                    game.score = scoreData.total;
                    
                    // Add to highscores
                    addHighscore(game.difficulty, scoreData.total, scoreData.stats);
                    
                    // Create score breakdown display
                    const breakdown = `
                        <h3>üéâ MISSION SUCCESS! üéâ</h3>
                        <div style="background: #333; padding: 15px; border-radius: 5px; margin: 10px 0;">
                            <h4>Score Breakdown:</h4>
                            <div>Base Landing: ${scoreData.breakdown.base}</div>
                            <div>Fuel Bonus: ${scoreData.breakdown.fuel}</div>
                            <div>Speed Bonus: ${scoreData.breakdown.speed}</div>
                            <div>Time Bonus: ${scoreData.breakdown.time}</div>
                            <div>Precision Bonus: ${scoreData.breakdown.precision}</div>
                            <div style="border-top: 1px solid #666; margin-top: 10px; padding-top: 10px;">
                                <strong>Total Score: ${scoreData.total}</strong>
                            </div>
                            <div style="font-size: 12px; color: #ccc; margin-top: 5px;">
                                Difficulty Multiplier: x${scoreData.breakdown.multiplier}
                            </div>
                        </div>
                    `;
                    
                    showGameOver("Mission Accomplished!", "Perfect landing! You're a true pilot.", breakdown);
                } else {
                    // Crash
                    game.gameOver = true;
                    game.score = 0;
                    
                    // Play crash sound
                    playCrashSound();
                    
                    let message = "Crashed! ";
                    if (!isOnLandingPad) message += "You must land on the flat surfaces.";
                    else if (speed >= 2) message += "Landing speed too high!";
                    else if (angle >= 0.3) message += "Landing angle too steep!";
                    
                    showGameOver("Mission Failed", message, "");
                }
                
                lander.vx = 0;
                lander.vy = 0;
                lander.y = terrainHeight - lander.size;
            }
        }
        
        function startGame(difficulty) {
            console.log('Starting game with difficulty:', difficulty);
            
            // Initialize audio on first user interaction
            if (!audioContext) {
                initAudio();
            }
            
            playButtonSound();
            
            // Start music only if enabled
            if (musicEnabled) {
                startBackgroundMusic();
            }
            
            game.difficulty = difficulty;
            game.gameStarted = true;
            game.startTime = Date.now();
            game.score = 0;
            
            document.getElementById('difficultyScreen').style.display = 'none';
            
            resetLander();
            generateTerrain();
            
            // Random initial velocity left or right (increased)
            game.lander.vx = (Math.random() - 0.5) * 0.6; // Random between -0.3 and +0.3
        }
        
        function showDifficultyScreen() {
            playButtonSound();
            stopBackgroundMusic();
            game.gameStarted = false;
            game.gameOver = false;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('difficultyScreen').style.display = 'block';
        }
        
        function resetLander() {
            game.lander = {
                x: 400,
                y: 50,
                vx: 0,
                vy: 0,
                angle: 0,
                fuel: 100,
                thrust: false,
                thrustLeft: false,
                thrustRight: false,
                size: 15
            };
            game.gameOver = false;
            game.won = false;
            game.paused = false;
        }
        
        function restartGame() {
            resetLander();
            generateTerrain();
            document.getElementById('gameOver').style.display = 'none';
            
            // Add random initial velocity (increased)
            game.lander.vx = (Math.random() - 0.5) * 0.6; // Random between -0.3 and +0.3
            game.startTime = Date.now(); // Reset start time for scoring
            game.score = 0; // Reset score
        }
        
        function showGameOver(title, message, scoreBreakdown = "") {
            document.getElementById('gameOverTitle').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('scoreBreakdown').innerHTML = scoreBreakdown;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function drawStars() {
            ctx.fillStyle = '#fff';
            for (let star of game.stars) {
                ctx.globalAlpha = star.brightness;
                ctx.fillRect(star.x, star.y, 1, 1);
            }
            ctx.globalAlpha = 1;
        }
        
        function drawTerrain() {
            ctx.strokeStyle = '#666';
            ctx.fillStyle = '#333';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            
            for (let point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 3;
            for (let i = 0; i < terrain.length - 1; i++) {
                if (terrain[i].isLandingPad) {
                    ctx.beginPath();
                    ctx.moveTo(terrain[i].x, terrain[i].y);
                    ctx.lineTo(terrain[i + 1].x, terrain[i + 1].y);
                    ctx.stroke();
                }
            }
        }
        
        function drawLander() {
            const lander = game.lander;
            
            ctx.save();
            ctx.translate(lander.x, lander.y);
            ctx.rotate(lander.angle);
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(-8, -8, 16, 16);
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-8, 8);
            ctx.lineTo(-12, 16);
            ctx.moveTo(8, 8);
            ctx.lineTo(12, 16);
            ctx.stroke();
            
            if (lander.thrust && lander.fuel > 0) {
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.moveTo(-4, 8);
                ctx.lineTo(0, 20 + Math.random() * 10);
                ctx.lineTo(4, 8);
                ctx.closePath();
                ctx.fill();
            }
            
            if (lander.thrustLeft && lander.fuel > 0) {
                ctx.fillStyle = '#4444ff';
                ctx.fillRect(8, -2, 8, 4);
            }
            if (lander.thrustRight && lander.fuel > 0) {
                ctx.fillStyle = '#4444ff';
                ctx.fillRect(-16, -2, 8, 4);
            }
            
            ctx.restore();
        }
        
        function drawFuelGauge() {
            if (!game.gameStarted || game.gameOver) return;
            
            const gaugeX = canvas.width - 120;
            const gaugeY = 20;
            const gaugeWidth = 100;
            const gaugeHeight = 20;
            
            ctx.fillStyle = '#333';
            ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
            
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
            
            const fuelPercent = Math.max(0, game.lander.fuel / 100);
            const fuelWidth = (gaugeWidth - 4) * fuelPercent;
            
            if (fuelPercent > 0.5) {
                ctx.fillStyle = '#0f0';
            } else if (fuelPercent > 0.25) {
                ctx.fillStyle = '#ff0';
            } else {
                ctx.fillStyle = '#f00';
            }
            
            ctx.fillRect(gaugeX + 2, gaugeY + 2, fuelWidth, gaugeHeight - 4);
            
            ctx.fillStyle = '#fff';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText('FUEL', gaugeX - 5, gaugeY + 15);
            
            ctx.textAlign = 'center';
            ctx.fillText(Math.round(game.lander.fuel) + '%', gaugeX + gaugeWidth/2, gaugeY + 15);
            ctx.textAlign = 'left';
        }
        
        function drawPauseOverlay() {
            if (!game.paused) return;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 40);
            
            ctx.font = '18px Courier New';
            ctx.fillText('Press ENTER to resume', canvas.width / 2, canvas.height / 2 + 20);
            
            ctx.font = '14px Courier New';
            ctx.fillStyle = '#ccc';
            ctx.fillText(`Fuel: ${Math.round(game.lander.fuel)}%`, canvas.width / 2, canvas.height / 2 + 60);
            ctx.fillText(`Altitude: ${Math.max(0, Math.round((canvas.height - game.lander.y) / 5))}m`, canvas.width / 2, canvas.height / 2 + 80);
            const velocity = Math.sqrt(game.lander.vx * game.lander.vx + game.lander.vy * game.lander.vy);
            ctx.fillText(`Velocity: ${velocity.toFixed(1)} m/s`, canvas.width / 2, canvas.height / 2 + 100);
            
            ctx.textAlign = 'left';
        }
        
        function updateUI() {
            const lander = game.lander;
            const altitude = Math.max(0, Math.round((canvas.height - lander.y) / 5));
            const velocity = Math.sqrt(lander.vx * lander.vx + lander.vy * lander.vy);
            
            document.getElementById('score').textContent = game.score;
            document.getElementById('fuel').textContent = Math.max(0, Math.round(lander.fuel));
            document.getElementById('altitude').textContent = altitude;
            document.getElementById('velocity').textContent = velocity.toFixed(1);
        }
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (game.gameStarted) {
                handleInput();
                updatePhysics();
                
                drawStars();
                drawTerrain();
                drawLander();
                drawFuelGauge();
                drawPauseOverlay();
                
                updateUI();
            } else {
                drawStars();
                
                ctx.fillStyle = '#fff';
                ctx.font = '24px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Select difficulty to begin mission', canvas.width / 2, canvas.height / 2);
                ctx.textAlign = 'left';
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize game
        generateStars();
        gameLoop();
    </script>
</body>
</html>
